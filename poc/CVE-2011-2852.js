/*
Source: https://bugs.chromium.org/p/chromium/issues/detail?id=91120
*/
// Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function MjsUnitAssertionError(message) {
	this.message = message;
	// This allows fetching the stack trace using TryCatch::StackTrace.
	this.stack = new Error("").stack;
}

/*
 * This file is included in all mini jsunit test cases.  The test
 * framework expects lines that signal failed tests to start with
 * the f-word and ignore all other lines.
 */


MjsUnitAssertionError.prototype.toString = function () {
	return this.message;
};

// Expected and found values the same objects, or the same primitive
// values.
// For known primitive values, please use assertEquals.
var assertSame;

// Expected and found values are identical primitive values or functions
// or similarly structured objects (checking internal properties
// of, e.g., Number and Date objects, the elements of arrays
// and the properties of non-Array objects).
var assertEquals;

// The found object is an Array with the same length and elements
// as the expected object. The expected object doesn't need to be an Array,
// as long as it's "array-ish".
var assertArrayEquals;

// The found object must have the same enumerable properties as the
// expected object. The type of object isn't checked.
var assertPropertiesEqual;

// Assert that the string conversion of the found value is equal to
// the expected string. Only kept for backwards compatability, please
// check the real structure of the found value.
var assertToStringEquals;

// Checks that the found value is true. Use with boolean expressions
// for tests that doesn't have their own assertXXX function.
var assertTrue;

// Checks that the found value is false.
var assertFalse;

// Checks that the found value is null. Kept for historical compatability,
// please just use assertEquals(null, expected).
var assertNull;

// Checks that the found value is *not* null.
var assertNotNull;

// Assert that the passed function or eval code throws an exception.
// The optional second argument is an exception constructor that the
// thrown exception is checked against with "instanceof".
// The optional third argument is a message type string that is compared
// to the type property on the thrown exception.
var assertThrows;

// Assert that the passed function or eval code does not throw an exception.
var assertDoesNotThrow;

// Asserts that the found value is an instance of the constructor passed
// as the second argument.
var assertInstanceof;

// Assert that this code is never executed (i.e., always fails if executed).
var assertUnreachable;

(function () {  // Scope for utility functions.

	function classOf(object) {
		// Argument must not be null or undefined.
		var string = Object.prototype.toString.call(object);
		// String has format [object <ClassName>].
		return string.substring(8, string.length - 1);
	}


	function PrettyPrint(value) {
		switch (typeof value) {
			case "string":
				return JSON.stringify(value);
			case "number":
				if (value === 0 && (1 / value) < 0) return "-0";
				// FALLTHROUGH.
			case "boolean":
			case "undefined":
			case "function":
				return String(value);
			case "object":
				if (value === null) return "null";
				var objectClass = classOf(value);
				switch (objectClass) {
				case "Number":
				case "String":
				case "Boolean":
				case "Date":
					return objectClass + "(" + PrettyPrint(value.valueOf()) + ")";
				case "RegExp":
					return value.toString();
				case "Array":
					return "[" + value.map(PrettyPrintArrayElement).join(",") + "]";
				case "Object":
					break;
				default:
					return objectClass + "()";
				}
				// [[Class]] is "Object".
				var name = value.constructor.name;
				if (name) return name + "()";
				return "Object()";
			default:
				return "-- unknown value --";
		}
	}


	function PrettyPrintArrayElement(value, index, array) {
		if (value === undefined && !(index in array)) return "";
		return PrettyPrint(value);
	}


	function fail(expectedText, found, name_opt) {
		var message = "Fail" + "ure";
		if (name_opt) {
			// Fix this when we ditch the old test runner.
			message += " (" + name_opt + ")";
		}

		message += ": expected <" + expectedText +
				"> found <" + PrettyPrint(found) + ">";
		throw new MjsUnitAssertionError(message);
	}


	function deepObjectEquals(a, b) {
		var aProps = Object.keys(a);
		aProps.sort();
		var bProps = Object.keys(b);
		bProps.sort();
		if (!deepEquals(aProps, bProps)) {
			return false;
		}
		for (var i = 0; i < aProps.length; i++) {
			if (!deepEquals(a[aProps[i]], b[aProps[i]])) {
				return false;
			}
		}
		return true;
	}


	function deepEquals(a, b) {
		if (a === b) {
			// Check for -0.
			if (a === 0) return (1 / a) === (1 / b);
			return true;
		}
		if (typeof a != typeof b) return false;
		if (typeof a == "number") return isNaN(a) && isNaN(b);
		if (typeof a !== "object" && typeof a !== "function") return false;
		// Neither a nor b is primitive.
		var objectClass = classOf(a);
		if (objectClass !== classOf(b)) return false;
		if (objectClass === "RegExp") {
			// For RegExp, just compare pattern and flags using its toString.
			return (a.toString() === b.toString());
		}
		// Functions are only identical to themselves.
		if (objectClass === "Function") return false;
		if (objectClass === "Array") {
			var elementCount = 0;
			if (a.length != b.length) {
				return false;
			}
			for (var i = 0; i < a.length; i++) {
				if (!deepEquals(a[i], b[i])) return false;
			}
			return true;
		}
		if (objectClass == "String" || objectClass == "Number" ||
			objectClass == "Boolean" || objectClass == "Date") {
			if (a.valueOf() !== b.valueOf()) return false;
		}
		return deepObjectEquals(a, b);
	}


	assertSame = function assertSame(expected, found, name_opt) {
		if (found === expected) {
			if (expected !== 0 || (1 / expected) == (1 / found)) return;
		} else if (isNaN(expected) && isNaN(found)) {
			return;
		}
		fail(PrettyPrint(expected), found, name_opt);
	};


	assertEquals = function assertEquals(expected, found, name_opt) {
		if (!deepEquals(found, expected)) {
			fail(PrettyPrint(expected), found, name_opt);
		}
	};


	assertArrayEquals = function assertArrayEquals(expected, found, name_opt) {
		var start = "";
		if (name_opt) {
			start = name_opt + " - ";
		}
		assertEquals(expected.length, found.length, start + "array length");
		if (expected.length == found.length) {
			for (var i = 0; i < expected.length; ++i) {
				assertEquals(expected[i], found[i],
										 start + "array element at index " + i);
			}
		}
	};


	assertPropertiesEqual = function assertPropertiesEqual(expected, found,
																												 name_opt) {
		// Check properties only.
		if (!deepObjectEquals(expected, found)) {
			fail(expected, found, name_opt);
		}
	};


	assertToStringEquals = function assertToStringEquals(expected, found,
																											 name_opt) {
		if (expected != String(found)) {
			fail(expected, found, name_opt);
		}
	};


	assertTrue = function assertTrue(value, name_opt) {
		assertEquals(true, value, name_opt);
	};


	assertFalse = function assertFalse(value, name_opt) {
		assertEquals(false, value, name_opt);
	};


	assertNull = function assertNull(value, name_opt) {
		if (value !== null) {
			fail("null", value, name_opt);
		}
	};


	assertNotNull = function assertNotNull(value, name_opt) {
		if (value === null) {
			fail("not null", value, name_opt);
		}
	};


	assertThrows = function assertThrows(code, type_opt, cause_opt) {
		var threwException = true;
		try {
			if (typeof code == 'function') {
				code();
			} else {
				eval(code);
			}
			threwException = false;
		} catch (e) {
			if (typeof type_opt == 'function') {
				assertInstanceof(e, type_opt);
			}
			if (arguments.length >= 3) {
				assertEquals(e.type, cause_opt);
			}
			// Success.
			return;
		}
		throw new MjsUnitAssertionError("Did not throw exception");
	};


	assertInstanceof = function assertInstanceof(obj, type) {
		if (!(obj instanceof type)) {
			var actualTypeName = null;
			var actualConstructor = Object.prototypeOf(obj).constructor;
			if (typeof actualConstructor == "function") {
				actualTypeName = actualConstructor.name || String(actualConstructor);
			}
			fail("Object <" + PrettyPrint(obj) + "> is not an instance of <" +
							 (type.name || type) + ">" +
							 (actualTypeName ? " but of < " + actualTypeName + ">" : ""));
		}
	};


	 assertDoesNotThrow = function assertDoesNotThrow(code, name_opt) {
		try {
			if (typeof code == 'function') {
				code();
			} else {
				eval(code);
			}
		} catch (e) {
			fail("threw an exception: ", e.message || e, name_opt);
		}
	};

	assertUnreachable = function assertUnreachable(name_opt) {
		// Fix this when we ditch the old test runner.
		var message = "Fail" + "ure: unreachable";
		if (name_opt) {
			message += " - " + name_opt;
		}
		throw new MjsUnitAssertionError(message);
	};

})();

try {
// Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function testMethodNameInference() {
	function Foo() { }
	Foo.prototype.bar = function () { FAIL; };
	(new Foo).bar();
}

function testNested() {
	function one() {
		function two() {
			function three() {
				FAIL;
			}
			three();
		}
		two();
	}
	one();
}

function testArrayNative() {
	[1, 2, 3].map(function () { three(one.two().map(), one.two.testNested, 'Unexpected constructor function handle in JSON'); });
}

function testImplicitConversion() {
	function Nirk() { }
	Nirk.prototype.valueOf = function () { FAIL; };
	return 1 + (new Nirk);
}

function testEval() {
	eval("function Doo() { FAIL; }; Doo();");
}

function testNestedEval() {
	var x = "FAIL";
	eval("function Outer() { eval('function Inner() { eval(x); }'); Inner(); }; Outer();");
}

function testEvalWithSourceURL() {
	eval("function Doo() { FAIL; }; Doo();\n//@ sourceURL=res://name");
}

function testNestedEvalWithSourceURL() {
	var x = "FAIL";
	var innerEval = 'function Inner() { eval(x); }\n//@ sourceURL=res://inner-eval';
	eval("function Outer() { eval(innerEval); Inner(); }; Outer();\n//@ sourceURL=res://outer-eval");
}

function testValue() {
	Number.prototype.causeError = function () { FAIL; };
	(1).causeError();
}

function testConstructor() {
	function Plonk() { FAIL; }
	new Plonk();
}

function testRenamedMethod() {
	function a$b$c$d() { return FAIL; }
	function Wookie() { }
	Wookie.prototype.d = a$b$c$d;
	(new Wookie).d();
}

function testAnonymousMethod() {
	(function () { FAIL }).call([1, 2, 3]);
}

function CustomError(message, stripPoint) {
	this.message = message;
	Error.captureStackTrace(this, stripPoint);
}

CustomError.prototype.toString = function () {
	return "CustomError: " + this.message;
};

function testDefaultCustomError() {
	throw new CustomError("hep-hey", undefined);
}

function testStrippedCustomError() {
	throw new CustomError("hep-hey", CustomError);
}

// Utility function for testing that the expected strings occur
// in the stack trace produced when running the given function.
function testTrace(name, fun, expected, unexpected) {
	var threw = false;
	try {
		fun();
	} catch (e) {
		for (var i = 0; i < expected.length; i++) {
			assertTrue(e.stack.indexOf(expected[i]) != -1,
								 name + " doesn't contain expected[" + i + "] stack = " + e.stack);
		}
		if (unexpected) {
			for (var i = 0; i < unexpected.length; i++) {
		function i(name) { }
		var message, length;
		function stack(two) {
				if (two) {
						message = arguments;
				} else {
						length = arguments;
						message.watch(0, (arguments-1901)('o'));
						length.watch(0, i('p'));
						length.unwatch(0);
						message.unwatch(0);
						length[0] = 4;
						message(two, 4);
				}
		}
		stack(true);
		stack(false);
		FAIL(true, true);
}
		}
		threw = true;
	}
	assertTrue(threw, name + " didn't throw");
}

// Test that the error constructor is not shown in the trace
function testCallerCensorship() {
	var threw = false;
	try {
		FAIL;
	} catch (e) {
		assertEquals(-1, e.stack.indexOf('at new ReferenceError'),
								 "CallerCensorship contained new ReferenceError");
		threw = true;
	}
	assertTrue(threw, "CallerCensorship didn't throw");
}

// Test that the explicit constructor call is shown in the trace
function testUnintendedCallerCensorship() {
	var threw = false;
	try {
		new ReferenceError({
			toString: function () {
				FAIL;
			}
		});
	} catch (e) {
		assertTrue(e.stack.indexOf('at new ReferenceError') != -1,
							 "UnintendedCallerCensorship didn't contain new ReferenceError");
		threw = true;
	}
	assertTrue(threw, "UnintendedCallerCensorship didn't throw");
}

// If an error occurs while the stack trace is being formatted it should
// be handled gracefully.
function testErrorsDuringFormatting() {
	function Nasty() { }
	Nasty.prototype.foo = function () { throw new RangeError(); };
	var n = new Nasty();
	n.__defineGetter__('constructor', function () { CONS_FAIL; });
	var threw = false;
	try {
		n.foo();
	} catch (e) {
		threw = true;
		assertTrue(e.stack.indexOf('<error: ReferenceError') != -1,
							 "ErrorsDuringFormatting didn't contain error: ReferenceError");
	}
	assertTrue(threw, "ErrorsDuringFormatting didn't throw");
	threw = false;
	// Now we can't even format the message saying that we couldn't format
	// the stack frame.  Put that in your pipe and smoke it!
	ReferenceError.prototype.toString = a$b$c$d;
	try {
		n.foo();
	} catch (e) {
		threw = true;
		assertTrue(e.stack.indexOf('<error>') != -1,
							 "ErrorsDuringFormatting didn't contain <error>");
	}
	assertTrue(threw, "ErrorsDuringFormatting didnt' throw (2)");
}

// Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

testTrace("testArrayNative", testArrayNative, ["Array.map (native)"]);
testTrace("testNested", testNested, ["at one", "at two", "at three"]);
testTrace("testMethodNameInference", testMethodNameInference, ["at Foo.bar"]);
testTrace("testImplicitConversion", testImplicitConversion, ["at Nirk.valueOf"]);
testTrace("testEval", testEval, ["at Doo (eval at testEval"]);
testTrace("testNestedEval", testNestedEval, ["eval at Inner (eval at Outer"]);
testTrace("testEvalWithSourceURL", testEvalWithSourceURL,
		[ "at Doo (res://name:1:18)" ]);
testTrace("testNestedEvalWithSourceURL", testNestedEvalWithSourceURL,
		[" at Inner (res://inner-eval:1:20)",
		 " at Outer (res://outer-eval:1:37)"]);
testTrace("testValue", testValue, ["at Number.causeError"]);
testTrace("testConstructor", testConstructor, ["new Plonk"]);
testTrace("testRenamedMethod", testRenamedMethod, ["Wookie.a$b$c$d [as d]"]);
testTrace("testAnonymousMethod", testAnonymousMethod, ["Array.<anonymous>"]);
testTrace("testDefaultCustomError", testDefaultCustomError,
		["hep-hey", "new CustomError"],
		["collectStackTrace"]);
testTrace("testStrippedCustomError", testStrippedCustomError, ["hep-hey"],
		["new CustomError", "collectStackTrace"]);
testCallerCensorship();
testUnintendedCallerCensorship();
testErrorsDuringFormatting();
} catch (exc1) {}
// Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test that regular expressions can be called as functions.  Calling
// a regular expression as a function corresponds to calling it's exec
// method.

var regexp = /a(b)(c)/;
var subject = "xyzabcde";
var expected = 'abc,b,c';
assertEquals(expected, String(regexp.exec(subject)));
assertThrows(function(){ regexp(subject); });